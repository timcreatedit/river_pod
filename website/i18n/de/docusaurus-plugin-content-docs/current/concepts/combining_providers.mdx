---
title: Kombinieren von Providern
---

Bevor Sie sich hiermit beschäftigen, sollten Sie sich zuerst [in Provider einlesen](/docs/concepts/providers).
In dieser Anleitung werden wir uns alles ansehen, was es über das Kombinieren von Providern zu wissen gibt.

## Kombinieren von Providern

Wir haben uns schon angeschaut, wie man einen simplen Provider erzeugt.
In der Realität wird es aber häufiger dazu kommen, dass ein Provider den State eines
anderen Providers auslesen möchte.

Um dies zu tun, können wir das [ref] Objekt, welches dem Callback unseres Providers
übergeben wird, und seine [watch] Methode verwenden.

Betrachten Sie den folgenden Provider als Beispiel:

```dart
final cityProvider = Provider((ref) => 'London');
```

Wir können nun einen weiteren Provider erzeugen, der unseren `cityProvider` konsumiert:

```dart
final weatherProvider = FutureProvider((ref) async {
  // Wir verwenden `ref.watch` um einem anderen Provider zuzuhören, und 
  // übergeben den Provider, den wir konsumieren möchten. Hier: cityProvider
  final city = ref.watch(cityProvider);

  // Wir können das Ergebnis verwenden um etwas mit dem Wert von `cityProvider` zu machen.
  return fetchWeather(city: city);
});
```

Das war's schon! Wir haben einen Provider erstellt, der von einem anderen Provider
abhängig ist.

## FAQ

### Was wenn der Wert, dem wir zuhören sich mit der Zeit ändert?

Je nachdem welchem Provider Sie zuhören, kann sich der erhaltene Wert mit der
Zeit ändern.
Sie könnten zum Beispiel einem [StateNotifierProvider] zuhören, oder der konsumierte
Provider wurde mit [ProviderContainer.refresh]/[ref.refresh] dazu gezwungen, sich zu
aktualisieren.

Wenn Sie [watch] verwenden, ist Riverpod in der Lage Änderungen zu erkennen und wird
Provider erneut ausführen wenn nötig.

Das kann bei dynamisch berechnetem State sehr nützlich sein.
Betrachten wir zum Beispiel einen [StateNotifierProvider], der eine To-Do Liste zur Verfügung stellt:

```dart
class TodoList extends StateNotifier<List<Todo>> {
  TodoList(): super(const []);
}

final todoListProvider = StateNotifierProvider((ref) => TodoList());
```

Ein üblicher Usecase wäre, dass die UI diese Liste von To-Dos filtert um
nur erledigte/unerledigte To-Dos anzuzeigen.

Eine einfache Art, ein solches Szenario zu implementieren, wäre es:

- einen [StateProvider], zu erzeugen, der die aktuell ausgewählte Filtermethode zur Verfügung stellt:

  ```dart
  enum Filter {
    none,
    completed,
    uncompleted,
  }

  final filterProvider = StateProvider((ref) => Filter.none);
  ```

//TODO
- dann einen separaten Provider zu schreiben, der die Filtermethode mit der To-Do Liste kombiniert
  und eine gefilterte To-Do Liste bereitstellt

  ```dart
  final filteredTodoListProvider = Provider<List<Todo>>((ref) {
    final filter = ref.watch(filterProvider);
    final todos = ref.watch(todoListProvider);

    switch (filter) {
      case Filter.none:
        return todos;
      case Filter.completed:
        return todos.where((todo) => todo.completed).toList();
      case Filter.uncompleted:
        return todos.where((todo) => !todo.completed).toList();
    }
  });
  ```

Unsere UI kann dann dem `filteredTodoListProvider` zuhören.
Mit diesem Ansatz wird sich die UI automatisch updaten, wenn sich entweder die Filtermethode, oder
die To-Do Liste ändert.

Wenn Sie diesen Ansatz in Aktion sehen möchten, können Sie sich den Quellcode des [To-Do Listen
Beispiels](https://github.com/rrousselGit/river_pod/tree/master/examples/todos) ansehen.


:::info
Dieses Verhalten ist nicht auf [Provider] beschränkt und funktioniert mit allen Arten von Providern.

Es wäre zum Beispiel möglich, [watch] mit einem [FutureProvider] zu verbinden um ein Such-Feature zu
implementieren, oder, live Konfigurations-Änderungen zuzuhören:

```dart
// The current search filter
final searchProvider = StateProvider((ref) => '');

/// Configurations which can change over time
final configsProvider = StreamProvider<Configuration>(...);

final charactersProvider = FutureProvider<List<Character>>((ref) async {
  final search = ref.watch(searchProvider);
  final configs = await ref.watch(configsProvider.future);
  final response = await dio.get('${configs.host}/characters?search=$search');

  return response.data.map((json) => Character.fromJson(json)).toList();
});

```

Dieser Code fragt eine Liste von Charaktern von einem Service ab und aktualisiert die Liste
automatisch, sobald sich die Suchanfrage, oder die Konfigurationen ändern.
:::

### Kann ich einen Provider auslesen, ohne ihm zuzuhören?

Manchmal möchte man in einem Provider den Inhalt eines anderen Providers auslesen, ohne dass der bereitgestellte Wert
bei jeder Änderung dieses Inhalts neu erstellt wird.

Ein Beispiel dafür wäre ein `Repository, das von einem anderen Provider einen User Token für
die Authentifizierung ausliest.
Es wäre möglich [watch] zu benutzen und jedes mal ein neues Repository zu erstellen, wenn sich der Token
ändert, das würde allerdings wenig bis gar nichts bringen.

In dieser Situation kann [read] benutzt werden, was ähnlich zu [watch] ist aber den Provider nicht veranlasst,
seinen Wert neu zu erzeugen wenn der gelesene Wert sich ändert.

In diesem Fall ist es eine übliche Praxis, dem erstellten Objekt `ref.read` zu übergeben.
Das Objekt ist dann in der Lage, zu jedem Zeitpunkt die Werte von Providern zu lesen.

```dart
final userTokenProvider = StateProvider<String>((ref) => null);

final repositoryProvider = Provider((ref) => Repository(ref.read));

class Repository {
  Repository(this.read);

  /// Die `ref.read` Funktion
  final Reader read;

  Future<Catalog> fetchCatalog() async {
    String token = read(userTokenProvider);

    final response = await dio.get('/path', queryParameters: {
      'token': token,
    });

    return Catalog.fromJson(response.data);
  }
}
```

:::note
Es ist auch möglich, `ref` statt `ref.read` zu übergeben:

```dart
final repositoryProvider = Provider((ref) => Repository(ref));

class Repository {
  Repository(this.ref);

  final Ref ref;
}
```

Der einzige Unterschied ist, dass das Übergeben von `ref.read` den Code etwas vereinfacht
und sicherstellt, dass das Objekt niemals `ref.watch` verwendet.
:::

:::danger Rufen Sie **NICHT** [read] innerhalb eines Providers.

```dart
final myProvider = Provider((ref) {
  // `read` hier ist schlechte Praxis
  final value = ref.read(anotherProvider);
});
```

Falls Sie [read] mit dem Ziel benutzt haben, unerwünschte Rebuilds eines Objekts zu verhindern,
lesen Sie [My provider updates too often, what can I do?](#mein-provider-aktualisiert-sich-zu-oft-was-kann-ich-tun).
:::

### Wie testet man ein Objekt, das [read] als Parameter im Konstruktor übergeben bekommt?

Wenn Sie das Pattern verwenden, das in [Kann ich einen Provider auslesen, ohne ihm zuzuhören?](#kann-ich-einen-provider-auslesen-ohne-ihm-zuzuhören)
beschrieben wird, fragen Sie sich vielleicht wie Sie für das Objekt Tests schreiben können.

In diesem Szenario sollten Sie in Betracht ziehen, statt des Objekts den Provider direkt zu testen.
Dies ist mit der [ProviderContainer] Klasse möglich.

```dart
final repositoryProvider = Provider((ref) => Repository(ref.read));

test('ruft Katalog ab', () async {
  final container = ProviderContainer();
  addTearOff(container.dispose);

  Repository repository = container.read(repositoryProvider);

  await expectLater(
    repository.fetchCatalog(),
    completion(Catalog()),
  );
});
```

### Mein Provider aktualisiert sich zu oft, was kann ich tun?

Wenn Ihr Ojekt zu oft neu erzeugt wird, kann es sein, dass Ihr Provider Objekten zuhört,
die Ihn nicht interessieren sollten.

Beispielsweise könnte es Sein, dass Sie einem `Configuration` Objekt zuhören, davon aber
nur das `host` Feld verwenden.
Indem Sie dem gesamten `Configuration` Objekt zuhören, wird der Provider auch neu evaluiert,
wenn sich andere Felder als `host` ändern. Das kann unerwünscht sein.

Die Lösung hierfür ist es, einen separaten Provider zu schreiben, der _nur_ bereitstellt,
was aus `Configuration` benötigt wird (also `host`):

**VERMEIDEN** Sie es dem gesamten Objekt zuzuhören:

```dart
final configsProvider = StreamProvider<Configuration>(...);

final productsProvider = FutureProvider<List<Product>>((ref) async {
  // Führt dazu, dass productsProvider alle Produkte neu abfragt, wenn sich irgendetwas
  // in der Konfiguration ändert.
  final configs = await ref.watch(configsProvider.future);

  return dio.get('${configs.host}/products');
});
```

**Bevorzugen** Sie es, nur dem zuzuhören, was Sie auch verwenden:

```dart
final configsProvider = StreamProvider<Configuration>(...);

/// Ein Provider, der nur den aktuellen Host bereitstellt.
final _hostProvider = FutureProvider<String>((ref) async {
  final config = await ref.watch(configsProvider.future);
  return config.host;
});

final productsProvider = FutureProvider<List<Product>>((ref) async {
  // Hört nur dem Host zu. Wenn sich etwas anderes in der Konfiguration ändert, wird
  // der Provider nicht sinnlos neu evaluiert.
  final host = await ref.watch(_hostProvider.future);

  return dio.get('$host/products');
});
```

[Provider]: ../providers/provider
[StatepPovider]: ../providers/state_provider
[FutureProvider]: ../providers/future_provider
[StateNotifierProvider]: ../providers/state_notifier_provider
[ref]: https://pub.dev/documentation/riverpod/latest/riverpod/Ref-class.html
[watch]: https://pub.dev/documentation/riverpod/latest/riverpod/Ref/watch.html
[read]: https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html
[ProviderContainer.refresh]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer/refresh.html
[ref.refresh]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/WidgetRef/refresh.html
